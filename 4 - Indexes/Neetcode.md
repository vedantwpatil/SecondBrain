---
id: Neetcode
aliases: []
tags: []
---

2024-07-02 16:02

Status: 

Tags: 

# Neetcode

**Definition:** A list of algorithmic problems which I want to solve to land a [[Software Engineer]] role.  

## Topics:

There are a bunch of topics which are considered to be important to know, I have linked the topics which will redirect you to the category where you can see all the questions and detailed solutions for each question

## Takeaways
- [[#Arrays and Hashing Takeaways]]
- [[#Two Pointers Takeaways]]

## Problems 
- [[#Arrays and Hashing]]
- [[#Two Pointers]]
- [[#Stack]]
- [[#Binary Search]]
- [[#Sliding Window]]
- [[#Linked List]]
- [[#Trees]]
- [[#Tries]]
- [[#Heap/Priority Queue]]
- [[#Intervals]]
- [[#Greedy]]
- [[#Backtracking]]
- [[#1-D Dynamic Programming]]
- [[#Graphs]]
- [[#Advanced Graphs]]
- [[#2-D Dynamic Programming]]
- [[#Bit Manipulation]]
- [[#Math and Geometry]]

## Problems 
### Arrays and Hashing
[[Contains Duplicate]]
[[Valid Anagram]]
[[Two Sum]]
[[Group Anagrams]]
[[Top K Frequent Elements]]
[[Encode and Decode Strings]]
[[Product of Array Except Self]]
[[Valid Sudoku]]
[[Longest Consecutive Sequence]]

### Two Pointers
[[Valid Palindrome]]
[[Two Sum II Input Array is Sorted]]
[[ThreeSum]]
[[Container With Most Water]]
[[Trapping Rain Water]]

### Stack

### Binary Search

### Sliding Window
[[Best Time to Buy and Sell Stock]]
[[Longest Substring Without Repeating Characters]]
[[Longest Repeating Character Replacement]]
[[Permutation in String]]
[[Minimum Window Substring]]
[[Sliding Window Maximum]]
### Linked List

### Trees

### Tries

### Heap/Priority Queue

### Intervals

### Greedy 

### Backtracking 

### 1-D Dynamic Programming 

### Graphs

### Advanced Graphs 

### 2-D Dynamic Programming 

### Bit Manipulation 

### Math and Geometry 

### Arrays and Hashing Takeaways
While trying to solve these types of questions, the most common thing to look for is if we need to count the frequency of elements that can be a dead giveaway since the best way to do that is by using a [[Hash Tables|hashmap]] however sometimes it can be more efficient to use a [[HashSets|hashset]]. 

I think that these can be some of the most simple problems you could face, however they are usually concealed by a larger problem to make it harder. 

### Two Pointers Takeaways
Two pointer questions often have a while loop with the condition while the left pointer is less then the right pointer with the left pointer being indexed at the start of the array and the right pointer being indexed at the end. 

There is also the fast and slow technique, frequently used in linked lists. Questions which are searching for pairs or triplets or are checking for palindrome are often times where you'll need two pointers to solve the problem.

After indexing your pointers you either increment them or decrement them until you hit a certain condition, after this you either change the pointer or return some value. 
